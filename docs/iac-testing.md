# Infrastructure as Code (IAC) Testing Guide

## Overview

This guide provides patterns and best practices for writing unit tests for AWS infrastructure code using SST (v2.49.6+) and AWS CDK. Tests use Vitest 4.x and aws-cdk-lib/assertions for validating CloudFormation templates generated by CDK constructs.

## Testing Philosophy

### Core Philosophy: Quality Over Quantity

**Write fewer, better tests that are easier to maintain.** Focus on testing critical infrastructure properties with grouped assertions rather than creating many fragmented micro-tests. Aim for small numbers of well-organized tests per construct instead of 10+ micro-tests.

### Key Principles

1. **Group related assertions together**
   - Test multiple properties of the same resource in one test
   - Group security properties together (encryption + public access + versioning)
   - Group configuration properties together (runtime + handler + environment)
   - Aim for 3-6 grouped tests per construct, not 10+ micro-tests

2. **Test CloudFormation output, not implementation details**
   - Validate what gets deployed, not how it's constructed
   - Tests should survive refactoring as long as the deployed resources remain the same

3. **Test from the user's perspective**
   - API endpoint tests are more valuable than testing internal domain functions
   - Tests should reflect real user interactions with your system

4. **Focus on critical infrastructure properties**
   - Security settings (encryption, IAM policies, public access)
   - Resource references and cross-stack dependencies
   - Required configurations that affect deployment or behavior

5. **Write resilient tests**
   - Use flexible matchers (`Match.objectLike()`) to avoid brittleness from CDK updates
   - Isolate tests so they can run reliably
   - Mock account-specific helpers to avoid environment dependencies

### Three Types of Tests

Following SST's testing model, there are three types of tests for infrastructure:

1. **Domain/Business Logic Tests** - Test your core business logic
   - Most granular, tests specific functions and classes
   - Example: Testing an `Article.create()` function

2. **API/Integration Tests** - Test your endpoints and request handlers
   - Most valuable for catching real-world issues
   - Tests from user's perspective, ignoring implementation details
   - Example: Making a GraphQL mutation and verifying the result

3. **Infrastructure/Stack Tests** - Test your CloudFormation templates
   - Enforce infrastructure policies and prevent regressions
   - Ensure critical settings aren't accidentally changed
   - Example: Verifying DynamoDB has point-in-time recovery enabled

## Project Structure

```
services/my-service/
├── infra/
│   ├── SomeConstruct.ts
│   ├── SomeConstruct.test.ts   # Co-located with construct
│   ├── Main.ts
│   └── Main.test.ts
├── vitest.config.ts
└── tsconfig.json
```

## Test Configuration

### vitest.config.ts

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    fileParallelism: false, // CRITICAL: SST requires sequential execution
    hookTimeout: 30000, // SST initialization can be slow
    testTimeout: 30000,
    include: ['**/*.{test,spec}.{ts,tsx}'],
    env: {
      SST_STAGE: 'test',
      SST_APP: 'my-service', // Match your service name
    },
    coverage: {
      provider: 'v8',
      reporter: [['lcov', { projectRoot: '../../' }], 'text'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/index.ts',
      ],
    },
  },
});
```

### tsconfig.json

```json
{
  "extends": "@config/tsconfig/sst.json",
  "include": [
    "infra",
    "sst.config.ts",
    "tsconfig.json",
    "eslint.config.js",
    "vitest.config.ts"
  ]
}
```

### package.json

```json
{
  "scripts": {
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage"
  },
  "devDependencies": {
    "vitest": "catalog:"
  }
}
```

## SST Test Pattern

### Basic Test Structure

```typescript
import { describe, it, expect, beforeAll, vi } from 'vitest';
import { Template, Match } from 'aws-cdk-lib/assertions';
import { RemovalPolicy } from 'aws-cdk-lib';
import { initProject } from 'sst/project.js';
import { App, getStack, StackContext } from 'sst/constructs';
import { MyConstruct } from './MyConstruct.ts';

// Mock account-specific helpers to avoid validation in tests
vi.mock('@lib/sst-helpers', () => ({
  removalPolicy: {
    retainForPermanentStage: vi.fn(() => RemovalPolicy.DESTROY),
  },
}));

describe('MyConstruct', () => {
  // Initialize SST project once before all tests
  beforeAll(async () => {
    await initProject({});
  });

  it('should create resource with default configuration', async () => {
    // Create SST app in deploy mode
    const app = new App({ mode: 'deploy' });

    // Define stack function (MUST be named const for getStack to work)
    const Stack = function (ctx: StackContext) {
      new MyConstruct(ctx.stack, 'test-construct');
    };

    // Register stack and synthesize
    app.stack(Stack);
    await app.finish();

    // Get CloudFormation template
    const template = Template.fromStack(getStack(Stack));

    // Assert on template
    template.resourceCountIs('AWS::S3::Bucket', 1);
    template.hasResourceProperties('AWS::S3::Bucket', {
      BucketEncryption: {
        ServerSideEncryptionConfiguration: [
          {
            ServerSideEncryptionByDefault: {
              SSEAlgorithm: 'AES256',
            },
          },
        ],
      },
    });
  });
});
```

### Critical Patterns

1. **Call `initProject({})` appropriately**
   - **Default:** Call once in `beforeAll()` for all tests in a file
   - **Exception:** If tests need different `initProject()` params, call in each test's `beforeEach()` or directly in the test
   - Initializes SST's internal state

2. **Use `const Stack = function (ctx: StackContext)` syntax**
   - Named function expression is required for `getStack(Stack)` to work
   - Arrow functions won't work: `const Stack = (ctx: StackContext) => {}`

3. **Always use `App({ mode: 'deploy' })`**
   - Ensures proper CloudFormation synthesis
   - Test mode uses placeholder values

4. **Always call `await app.finish()`**
   - Completes synthesis process
   - Required before accessing template

5. **Mock `@lib/sst-helpers` for account-specific logic**
   - SST test mode uses `my-account` which won't match real account IDs
   - Mock functions that validate AWS accounts or stages

### Advanced: Per-Test initProject()

When tests need different `initProject()` configuration, call it per test instead of in `beforeAll()`:

```typescript
describe('MyConstruct with different configs', () => {
  it('should work with custom stage in initProject', async () => {
    // Initialize with custom params for this test
    await initProject({
      stage: 'custom-stage',
    });

    const app = new App({ mode: 'deploy' });
    const Stack = function (ctx: StackContext) {
      // ctx.stage will be 'custom-stage'
      new MyConstruct(ctx.stack, 'test');
    };
    app.stack(Stack);
    await app.finish();

    const template = Template.fromStack(getStack(Stack));
    // Assertions...
  });

  it('should work with different config', async () => {
    // Initialize with different params
    await initProject({
      stage: 'another-stage',
    });

    const app = new App({ mode: 'deploy' });
    const Stack = function (ctx: StackContext) {
      // ctx.stage will be 'another-stage'
      new MyConstruct(ctx.stack, 'test');
    };
    app.stack(Stack);
    await app.finish();

    const template = Template.fromStack(getStack(Stack));
    // Assertions...
  });
});
```

**When to use per-test `initProject()`:**

- Tests need different stage values
- Tests need different SST configuration
- Tests need to validate stage-dependent behavior

**When to use `beforeAll()` `initProject()`:**

- All tests use the same SST configuration (most common)
- Faster test execution (initialization happens once)

## AWS CDK Assertions

### Import Assertions

```typescript
import { Template, Match, Capture } from 'aws-cdk-lib/assertions';
```

### Resource Counting

```typescript
// Exact count
template.resourceCountIs('AWS::Lambda::Function', 1);

// At least one
template.resourceCountIs('AWS::S3::Bucket', Match.anyValue());
```

### Property Assertions

#### Exact Matching (Brittle - Avoid)

```typescript
// BAD: Breaks when CDK adds new properties
template.hasResourceProperties('AWS::S3::Bucket', {
  BucketName: 'my-bucket',
  BucketEncryption: {
    /* ... */
  },
  VersioningConfiguration: {
    /* ... */
  },
  // If CDK adds a new property, this test fails
});
```

#### Flexible Matching (Recommended)

```typescript
// GOOD: Only validates properties you care about
template.hasResourceProperties(
  'AWS::S3::Bucket',
  Match.objectLike({
    BucketEncryption: {
      ServerSideEncryptionConfiguration: [
        {
          ServerSideEncryptionByDefault: {
            SSEAlgorithm: 'AES256',
          },
        },
      ],
    },
  })
);
```

### Match Utilities

```typescript
// Object with specific properties (ignores others)
Match.objectLike({
  Property: 'value',
});

// Array containing specific items (ignores others)
Match.arrayWith([Match.objectLike({ Key: 'Environment', Value: 'test' })]);

// String pattern matching
Match.stringLikeRegexp('arn:aws:s3:::my-bucket-.*');

// Any value (for counting or existence checks)
Match.anyValue();

// Absent property
Match.absent();
```

### Testing Resource References

CloudFormation uses `{ "Ref": "LogicalResourceId" }` for references:

```typescript
// Get all Lambda functions
const functions = template.findResources('AWS::Lambda::Function');
const functionLogicalId = Object.keys(functions)[0];

// Verify API Gateway references the function
template.hasResourceProperties(
  'AWS::ApiGateway::Method',
  Match.objectLike({
    Integration: Match.objectLike({
      Uri: Match.objectLike({
        'Fn::Join': Match.arrayWith([
          Match.arrayWith([
            Match.objectLike({
              'Fn::GetAtt': [functionLogicalId, 'Arn'],
            }),
          ]),
        ]),
      }),
    }),
  })
);
```

### Advanced: Capturing Values

```typescript
import { Capture } from 'aws-cdk-lib/assertions';

const roleCapture = new Capture();
template.hasResourceProperties('AWS::Lambda::Function', {
  Role: roleCapture,
});

// Use captured value in another assertion
const roleLogicalId = roleCapture.asObject()['Fn::GetAtt'][0];
template.hasResourceProperties('AWS::IAM::Role', {
  // ...
});
```

## Common Test Scenarios

### 1. Grouped Testing Pattern (Recommended)

**Real-world example** from `services/main-api/infra/Main.test.ts`:

```typescript
describe('Main API Stack', () => {
  // Test 1: Groups API creation, routes, and protocol together
  it('should create API Gateway with routes', async () => {
    template.resourceCountIs('AWS::ApiGatewayV2::Api', 1);
    template.hasResourceProperties(
      'AWS::ApiGatewayV2::Api',
      Match.objectLike({
        ProtocolType: 'HTTP',
      })
    );

    template.resourceCountIs('AWS::ApiGatewayV2::Route', 2);
    template.hasResourceProperties('AWS::ApiGatewayV2::Route', {
      RouteKey: 'ANY /hello',
    });
  });

  // Test 2: Groups authorization properties
  it('should create protected route with IAM authorizer', async () => {
    template.hasResourceProperties(
      'AWS::ApiGatewayV2::Route',
      Match.objectLike({
        RouteKey: 'ANY /protected',
        AuthorizationType: 'AWS_IAM',
      })
    );
  });

  // Test 3: Groups Lambda configuration (handler, runtime, resource count)
  it('should create Lambda function with correct handler', async () => {
    template.resourceCountIs('AWS::Lambda::Function', 1);
    template.hasResourceProperties(
      'AWS::Lambda::Function',
      Match.objectLike({
        Handler: 'index.handler',
        Runtime: Match.stringLikeRegexp('nodejs'),
      })
    );
  });

  // Test 4: Tests stack outputs
  it('should export API endpoint URL', async () => {
    const outputs = template.findOutputs('*');
    expect(Object.keys(outputs)).toContain('APIEndpoint');
  });
});
```

**Key benefits of this approach:**

- 4 focused tests instead of 10+ micro-tests
- Each test validates a logical grouping (API setup, security, Lambda, outputs)
- Multiple assertions per test when testing the same resource
- Easier to maintain and understand intent
- Faster execution (6 seconds vs 25 seconds)

**Compare with micro-test anti-pattern:**

```typescript
// ❌ BAD - Too fragmented (17 tests for same stack)
it('should create API Gateway', async () => {});
it('should set protocol to HTTP', async () => {});
it('should create route count', async () => {});
it('should create hello route', async () => {});
it('should create protected route', async () => {});
it('should set authorization type', async () => {});
// ... 11 more tests
```

This anti-pattern creates maintenance burden - when you add a new route, you might need to update 4+ separate tests instead of modifying one grouped test.

### 2. Testing S3 Bucket with Grouped Security Properties

```typescript
it('should enforce S3 security best practices', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new MyBucket(ctx.stack, 'test');
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Group: resource count + security properties + versioning in one test
  template.resourceCountIs('AWS::S3::Bucket', 1);
  template.hasResourceProperties(
    'AWS::S3::Bucket',
    Match.objectLike({
      BucketEncryption: Match.objectLike({
        ServerSideEncryptionConfiguration: Match.arrayWith([
          Match.objectLike({
            ServerSideEncryptionByDefault: {
              SSEAlgorithm: 'AES256',
            },
          }),
        ]),
      }),
      PublicAccessBlockConfiguration: {
        BlockPublicAcls: true,
        BlockPublicPolicy: true,
        IgnorePublicAcls: true,
        RestrictPublicBuckets: true,
      },
      VersioningConfiguration: {
        Status: 'Enabled',
      },
    })
  );
});
```

### 3. Testing Custom Configuration with Multiple Properties

```typescript
it('should accept custom configuration overrides', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new MyConstruct(ctx.stack, 'test', {
      bucketName: 'custom-bucket-name',
      versioning: false,
      lifecycleRules: [{ expirationInDays: 30 }],
    });
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Group: custom name + versioning + lifecycle in one test
  template.hasResourceProperties(
    'AWS::S3::Bucket',
    Match.objectLike({
      BucketName: 'custom-bucket-name',
      VersioningConfiguration: Match.objectLike({
        Status: 'Suspended',
      }),
      LifecycleConfiguration: Match.objectLike({
        Rules: Match.arrayWith([
          Match.objectLike({
            ExpirationInDays: 30,
          }),
        ]),
      }),
    })
  );
});
```

### 4. Testing Multiple Resources with Configuration

```typescript
it('should create multiple clients with OAuth configuration', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new UserPool(ctx.stack, 'test', {
      clients: [
        { clientName: 'web-client', allowedOAuthFlows: ['code'] },
        { clientName: 'mobile-client', allowedOAuthFlows: ['implicit'] },
      ],
    });
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Group: resource count + properties for each client
  template.resourceCountIs('AWS::Cognito::UserPoolClient', 2);

  template.hasResourceProperties(
    'AWS::Cognito::UserPoolClient',
    Match.objectLike({
      ClientName: 'web-client',
      AllowedOAuthFlows: ['code'],
    })
  );

  template.hasResourceProperties(
    'AWS::Cognito::UserPoolClient',
    Match.objectLike({
      ClientName: 'mobile-client',
      AllowedOAuthFlows: ['implicit'],
    })
  );
});
```

**Tip:** When testing resources with multiple instances, consider setting the `description` property (if available) to make assertions easier and more explicit:

```typescript
it('should create functions with correct configurations', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new Function(ctx.stack, 'api-handler', {
      handler: 'api.handler',
      runtime: 'nodejs20.x',
      memorySize: 512,
      description: 'API request handler', // Helpful for testing
    });
    new Function(ctx.stack, 'worker', {
      handler: 'worker.handler',
      runtime: 'nodejs20.x',
      memorySize: 1024,
      description: 'Background worker', // Helpful for testing
    });
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  template.resourceCountIs('AWS::Lambda::Function', 2);

  // Group: description + handler + runtime + memory for each function
  template.hasResourceProperties(
    'AWS::Lambda::Function',
    Match.objectLike({
      Description: 'API request handler',
      Handler: 'api.handler',
      Runtime: 'nodejs20.x',
      MemorySize: 512,
    })
  );

  template.hasResourceProperties(
    'AWS::Lambda::Function',
    Match.objectLike({
      Description: 'Background worker',
      Handler: 'worker.handler',
      Runtime: 'nodejs20.x',
      MemorySize: 1024,
    })
  );
});
```

This pattern works for any AWS resource that supports the `description` property. Check the AWS IAC MCP documentation tools to verify if a specific resource type supports it.

### 5. Testing Conditional Resources

```typescript
it('should handle optional resources based on configuration', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new UserPool(ctx.stack, 'test', {
      // No clients provided
      enableDomain: false,
    });
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Group: multiple conditional resource checks together
  template.resourceCountIs('AWS::Cognito::UserPool', 1);
  template.resourceCountIs('AWS::Cognito::UserPoolClient', 0);
  template.resourceCountIs('AWS::Cognito::UserPoolDomain', 0);
});
```

### 6. Testing Cross-Resource References and Integration

```typescript
it('should wire up Lambda, API Gateway, and IAM correctly', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new ApiWithLambda(ctx.stack, 'test');
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Get Lambda function logical ID for reference checks
  const functions = template.findResources('AWS::Lambda::Function');
  const functionLogicalId = Object.keys(functions)[0];

  // Group: API Gateway integration + IAM permissions + environment refs
  template.hasResourceProperties(
    'AWS::ApiGateway::Method',
    Match.objectLike({
      Integration: Match.objectLike({
        Uri: Match.objectLike({
          'Fn::Join': Match.arrayWith([
            Match.arrayWith([
              Match.objectLike({
                'Fn::GetAtt': [functionLogicalId, 'Arn'],
              }),
            ]),
          ]),
        }),
      }),
    })
  );

  // Verify Lambda has environment variables with resource references
  template.hasResourceProperties(
    'AWS::Lambda::Function',
    Match.objectLike({
      Environment: Match.objectLike({
        Variables: Match.objectLike({
          USER_POOL_ARN: Match.anyValue(),
          TABLE_NAME: Match.anyValue(),
        }),
      }),
    })
  );
});
```

### 7. Testing Stage-Dependent Configuration

````typescript
it('should apply production settings for permanent stages', async () => {
  await initProject({ stage: 'production' });

  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new MyConstruct(ctx.stack, 'test');
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Group: removal policy + backup + point-in-time recovery
  template.hasResourceProperties(
    'AWS::DynamoDB::Table',
    Match.objectLike({
      DeletionPolicy: 'Retain',
      PointInTimeRecoverySpecification: {
        PointInTimeRecoveryEnabled: true,
      },
    })
  );

  template.hasResourceProperties(
    'AWS::S3::Bucket',
    Match.objectLike({
      DeletionPolicy: 'Retain',
      VersioningConfiguration: {
        Status: 'Enabled',
      },
    })
  );
});

## Understanding CloudFormation Resources

### Using AWS IAC MCP Tools

When writing assertions, use AWS IAC MCP tools to understand CloudFormation resource schemas:

```typescript
// Use search_cloudformation_documentation tool
// Query: "AWS::Cognito::UserPool properties"

// Returns official AWS CloudFormation property documentation
// Use this to understand:
// - Property names (case-sensitive!)
// - Property types (string, number, object, array)
// - Nested property structures
// - Required vs optional properties
````

### Common CloudFormation Property Patterns

1. **Property Names are PascalCase in CloudFormation:**

   ```typescript
   // CDK Input (camelCase)
   new Bucket(stack, 'Bucket', {
     bucketName: 'my-bucket',
     encryption: BucketEncryption.S3_MANAGED,
   });

   // CloudFormation Output (PascalCase)
   {
     BucketName: 'my-bucket',
     BucketEncryption: { /* ... */ }
   }
   ```

2. **References use special CloudFormation functions:**

   ```typescript
   // Direct reference
   { "Ref": "LogicalResourceId" }

   // Get attribute
   { "Fn::GetAtt": ["LogicalResourceId", "Arn"] }

   // Join strings
   { "Fn::Join": ["", ["prefix-", { "Ref": "ResourceId" }]] }
   ```

3. **Boolean values:**

   ```typescript
   // Some use boolean
   BlockPublicAcls: true;

   // Some use string
   Status: 'Enabled'; // not true/false
   ```

## Snapshot Testing

### What Are Snapshot Tests?

Snapshot tests compare the entire synthesized CloudFormation template against a previously stored baseline template. They're useful for refactoring but have limitations.

### When to Use Snapshot Tests

**✅ Good use cases:**

- Refactoring construct implementations while keeping outputs the same
- Ensuring changes to shared constructs don't unexpectedly affect other stacks
- Quick smoke tests during development

**❌ Not ideal for:**

- Primary regression testing (too broad, fails on CDK updates)
- Catching specific infrastructure policy violations
- Testing security configurations

### Example Snapshot Test

```typescript
import { Template } from 'aws-cdk-lib/assertions';
import { App, getStack, StackContext } from 'sst/constructs';
import { initProject } from 'sst/project.js';
import { MyConstruct } from './MyConstruct';

describe('MyConstruct', () => {
  beforeAll(async () => {
    await initProject({});
  });

  it('matches snapshot', async () => {
    const app = new App({ mode: 'deploy' });
    const Stack = function (ctx: StackContext) {
      new MyConstruct(ctx.stack, 'test');
    };
    app.stack(Stack);
    await app.finish();

    const template = Template.fromStack(getStack(Stack));
    expect(template.toJSON()).toMatchSnapshot();
  });
});
```

### Snapshot Test Limitations

1. **CDK Updates Cause Changes**
   - CDK upgrades may add metadata or change resource organization
   - Template structure changes don't mean your deployment is wrong
   - Must manually review and accept new baseline

2. **Context Changes Affect Output**
   - Feature flags and context values alter synthesis
   - Environment-specific context can cause different outputs

3. **Too Broad for Regression Testing**
   - Small unintended change buried in large diff
   - Hard to identify what actually broke
   - Fine-grained assertions are better for catching regressions

### Best Practices for Snapshots

1. **Combine with fine-grained assertions**

   ```typescript
   it('should enforce security', async () => {
     // Fine-grained assertion for critical property
     template.hasResourceProperties(
       'AWS::S3::Bucket',
       Match.objectLike({
         BucketEncryption: Match.objectLike({
           ServerSideEncryptionConfiguration: Match.anyValue(),
         }),
       })
     );

     // Snapshot to catch unexpected changes
     expect(template.toJSON()).toMatchSnapshot();
   });
   ```

2. **Review snapshot diffs carefully**
   - Don't blindly accept changes
   - Understand why template changed
   - Verify change is intentional

3. **Keep snapshots focused**
   - Test individual constructs, not entire apps
   - Smaller snapshots = easier to review diffs

4. **Hold external factors constant**
   - Use same CDK version during refactoring
   - Don't change context values
   - Lock down dependencies during refactoring session

## Debugging Failed Tests

### View Full Template

```typescript
it('debug test', async () => {
  const app = new App({ mode: 'deploy' });
  const Stack = function (ctx: StackContext) {
    new MyConstruct(ctx.stack, 'test');
  };
  app.stack(Stack);
  await app.finish();

  const template = Template.fromStack(getStack(Stack));

  // Print entire template
  console.log(JSON.stringify(template.toJSON(), null, 2));
});
```

### Find All Resources

```typescript
// Get all resources of a type
const buckets = template.findResources('AWS::S3::Bucket');
console.log(JSON.stringify(buckets, null, 2));

// Get all resources in stack
const allResources = template.toJSON().Resources;
console.log(JSON.stringify(allResources, null, 2));
```

### Inspect Resource Properties

```typescript
const functions = template.findResources('AWS::Lambda::Function');
const functionLogicalId = Object.keys(functions)[0];
const functionProps = functions[functionLogicalId];
console.log('Function Properties:', JSON.stringify(functionProps, null, 2));
```

## Common Pitfalls

### 1. Using Arrow Functions for Stack

```typescript
// ❌ WRONG - getStack won't work
const Stack = (ctx: StackContext) => {
  new MyConstruct(ctx.stack, 'test');
};

// ✅ CORRECT
const Stack = function (ctx: StackContext) {
  new MyConstruct(ctx.stack, 'test');
};
```

### 2. Not Calling initProject

```typescript
// ❌ WRONG - SST not initialized
describe('MyConstruct', () => {
  it('should work', async () => {
    const app = new App({ mode: 'deploy' });
    // Error: SST not initialized
  });
});

// ✅ CORRECT
describe('MyConstruct', () => {
  beforeAll(async () => {
    await initProject({});
  });

  it('should work', async () => {
    const app = new App({ mode: 'deploy' });
    // Works correctly
  });
});
```

### 3. Not Calling app.finish()

```typescript
// ❌ WRONG - Template not synthesized
const app = new App({ mode: 'deploy' });
app.stack(Stack);
const template = Template.fromStack(getStack(Stack));
// Error: Stack not synthesized

// ✅ CORRECT
const app = new App({ mode: 'deploy' });
app.stack(Stack);
await app.finish(); // Synthesize first
const template = Template.fromStack(getStack(Stack));
```

### 4. Using Exact Property Matching

```typescript
// ❌ BRITTLE - Breaks on CDK updates
template.hasResourceProperties('AWS::S3::Bucket', {
  BucketName: 'my-bucket',
  BucketEncryption: {
    /* ... */
  },
  // If CDK adds any property, this fails
});

// ✅ FLEXIBLE
template.hasResourceProperties(
  'AWS::S3::Bucket',
  Match.objectLike({
    BucketName: 'my-bucket',
    // Only checks properties you specify
  })
);
```

### 5. Not Mocking Account-Specific Helpers

```typescript
// ❌ WRONG - Test fails on account validation
import { removalPolicy } from '@lib/sst-helpers';

const policy = removalPolicy.retainForPermanentStage();
// Error: Account my-account not found

// ✅ CORRECT - Mock the helper
vi.mock('@lib/sst-helpers', () => ({
  removalPolicy: {
    retainForPermanentStage: vi.fn(() => RemovalPolicy.DESTROY),
  },
}));
```

### 6. Parallel Test Execution

```typescript
// ❌ WRONG - SST doesn't support parallel tests
// vitest.config.ts
export default defineConfig({
  test: {
    fileParallelism: true, // SST state conflicts
  },
});

// ✅ CORRECT
export default defineConfig({
  test: {
    fileParallelism: false, // Sequential execution
  },
});
```

## What to Test

### Focus on Critical Properties, Not Comprehensive Coverage

**Quality over quantity**: Test the properties that matter most, not every single property. Group related assertions together for maintainability.

### Infrastructure Tests Should Verify

1. **Security and Compliance** (Group in 1-2 tests)
   - Encryption at rest and in transit
   - Public access blocking
   - IAM policies and permissions
   - Point-in-time recovery for databases
   - Backup configurations

   **Example**: Test all S3 security settings (encryption + public access + versioning) in one test

2. **Critical Resource Properties** (Group in 1-2 tests)
   - Minimum memory/CPU allocations
   - Timeout configurations
   - Retention policies (logs, backups)
   - Environment variables that affect behavior

   **Example**: Test all Lambda configuration (runtime + handler + environment + memory) in one test

3. **Resource Existence and Count** (Often combined with other tests)
   - Expected resources are created
   - Conditional resources (based on props)
   - No unexpected resources

   **Tip**: Include resource counts in the same test that validates properties

4. **Cross-Resource References** (1 test)
   - Lambda functions reference correct IAM roles
   - API Gateway integrations point to correct functions
   - Clients reference correct user pools
   - Environment variables contain correct resource ARNs

   **Example**: Test all cross-resource references in a single "integration" test

5. **Infrastructure Policies** (Group with security tests)
   - Resources meet organizational standards
   - No accidental changes to critical settings
   - Database names haven't changed (data loss prevention)
   - Functions have minimum required memory

### What NOT to Test

1. **CDK-Generated Properties**
   - Don't test every single property CDK generates
   - Don't test CDK's internal implementation details
   - Avoid exact matching of entire resource definitions

2. **Transient Implementation Details**
   - Database choice (DynamoDB vs PostgreSQL) - tests should work with either
   - Specific table names (unless critical for data persistence)
   - Internal construct implementation

3. **Properties That Change Frequently**
   - CDK metadata
   - Exact CloudFormation structure (use flexible matchers)
   - Properties added by CDK updates

### Good vs Bad Test Examples

**❌ Bad - Tests implementation details:**

```typescript
it('should create DynamoDB table with exact properties', async () => {
  // This breaks if you switch to PostgreSQL or change table structure
  template.hasResourceProperties('AWS::DynamoDB::Table', {
    TableName: 'articles-table',
    AttributeDefinitions: [...],
    KeySchema: [...]
  });
});
```

**✅ Good - Tests behavior:**

```typescript
it('should persist articles', async () => {
  // Works regardless of database choice
  const article = await Article.create('Title', 'https://url.com');
  const found = await Article.get(article.id);
  expect(found).toBeDefined();
});
```

**❌ Bad - Tests exact counts (breaks in parallel):**

```typescript
it('should create article', async () => {
  await Article.create('Title', 'https://url.com');
  const list = await Article.list();
  expect(list.length).toBe(1); // Fails if other tests create articles
});
```

**✅ Good - Tests isolated existence:**

```typescript
it('should create article', async () => {
  const article = await Article.create('Title', 'https://url.com');
  const list = await Article.list();
  expect(list.find((a) => a.id === article.id)).toBeDefined();
});
```

## Writing Effective Tests

### Refactor Common Test Code

Don't copy and paste setup logic. Extract into fixtures or helper functions:

**❌ Bad - Repetitive setup:**

```typescript
it('test 1', async () => {
  const app = new App({ mode: 'deploy' });
  const topicsStack = new Stack(app, 'Topics');
  const topic = new Topic(topicsStack, 'Topic');
  // ... test
});

it('test 2', async () => {
  const app = new App({ mode: 'deploy' });
  const topicsStack = new Stack(app, 'Topics');
  const topic = new Topic(topicsStack, 'Topic');
  // ... test
});
```

**✅ Good - Extracted helper:**

```typescript
function createTestStack(props?: Partial<StateMachineStackProps>) {
  const app = new App({ mode: 'deploy' });
  const topicsStack = new Stack(app, 'Topics');
  const topics = [new Topic(topicsStack, 'Topic')];

  const Stack = function (ctx: StackContext) {
    new StateMachineStack(ctx.stack, 'Stack', { topics, ...props });
  };

  app.stack(Stack);
  return { app, Stack };
}

it('test 1', async () => {
  const { app, Stack } = createTestStack();
  await app.finish();
  // ... test
});
```

### Group Related Assertions by Resource or Feature

Group multiple related assertions within a single test when they validate the same resource or feature. This creates maintainable tests that are easier to update when requirements change.

**❌ Bad - Over-fragmented tests:**

```typescript
// Too many micro-tests makes maintenance harder
it('should create user pool', async () => {
  template.resourceCountIs('AWS::Cognito::UserPool', 1);
});

it('should enforce minimum password length', async () => {
  template.hasResourceProperties(
    'AWS::Cognito::UserPool',
    Match.objectLike({
      PasswordPolicy: Match.objectLike({ MinimumLength: 8 }),
    })
  );
});

it('should auto-verify email addresses', async () => {
  template.hasResourceProperties(
    'AWS::Cognito::UserPool',
    Match.objectLike({
      AutoVerifiedAttributes: ['email'],
    })
  );
});

it('should enable optional MFA', async () => {
  template.hasResourceProperties(
    'AWS::Cognito::UserPool',
    Match.objectLike({
      MfaConfiguration: 'OPTIONAL',
    })
  );
});
```

**✅ Good - Grouped by feature:**

```typescript
// One test validates all security properties together
it('should configure user pool with security settings', async () => {
  template.resourceCountIs('AWS::Cognito::UserPool', 1);
  template.hasResourceProperties(
    'AWS::Cognito::UserPool',
    Match.objectLike({
      PasswordPolicy: Match.objectLike({ MinimumLength: 8 }),
      AutoVerifiedAttributes: ['email'],
      MfaConfiguration: 'OPTIONAL',
    })
  );
});
```

**Key principle**: Aim for 3-6 grouped tests per construct instead of 10+ micro-tests. Group assertions by:

- Resource type (e.g., all API Gateway properties together)
- Feature area (e.g., all security settings together)
- Logical concern (e.g., all authorization properties together)

### Use Descriptive Test Names

Test names should describe the expected behavior, not the implementation.

**❌ Bad names:**

```typescript
it('test password policy', async () => {});
it('should work', async () => {});
it('creates resources', async () => {});
```

**✅ Good names:**

```typescript
it('should enforce 8-character minimum password length', async () => {});
it('should block all public S3 bucket access', async () => {});
it('should reference user pool ARN in Lambda environment', async () => {});
```

### Isolate Tests for Parallel Execution

Tests must be independent and not affect each other.

**❌ Bad - Shared global state:**

```typescript
it('should create first article', async () => {
  await Article.create('First', 'url1');
  const list = await Article.list();
  expect(list.length).toBe(1); // Breaks if tests run in parallel
});

it('should create second article', async () => {
  await Article.create('Second', 'url2');
  const list = await Article.list();
  expect(list.length).toBe(2); // Breaks if tests run in parallel
});
```

**✅ Good - Isolated by user scope:**

```typescript
it('should create article for user1', async () => {
  const user = await createTestUser('user1');
  await Article.create(user.id, 'Title', 'url');
  const list = await Article.listForUser(user.id);
  expect(list.length).toBe(1); // Only checks this user's articles
});

it('should create article for user2', async () => {
  const user = await createTestUser('user2');
  await Article.create(user.id, 'Title', 'url');
  const list = await Article.listForUser(user.id);
  expect(list.length).toBe(1); // Separate user, won't conflict
});
```

### Test Longevity

Tests live as long as your code. Invest in their quality:

1. **Readable** - Future you should understand the test immediately
2. **Maintainable** - Easy to update when requirements change
3. **Reliable** - Consistent results, no flakiness
4. **Fast** - Quick feedback loop encourages running tests often

## Running Tests

```bash
# Watch mode (interactive)
pnpm test

# Single run (CI)
pnpm test:run

# With coverage
pnpm test:coverage

# Specific file
vitest run infra/MyConstruct.test.ts

# Type check before tests
pnpm type-check && pnpm test:run

# Full validation
pnpm type-check && pnpm lint && pnpm test:run
```

## Test Organization

### File Naming

- Co-locate tests with constructs: `MyConstruct.test.ts` next to `MyConstruct.ts`
- Use `.test.ts` suffix (not `.spec.ts`) for consistency
- Match construct name: `UserPool.ts` → `UserPool.test.ts`

### Test Grouping

**Prefer flat structure with grouped assertions** over nested `describe` blocks. Aim for 3-6 tests per construct.

**❌ Bad - Overly nested, too many micro-tests:**

```typescript
describe('UserPool', () => {
  describe('constructor', () => {
    it('should create user pool', async () => {});
    it('should set correct id', async () => {});
  });

  describe('password policy', () => {
    it('should set minimum length', async () => {});
    it('should require lowercase', async () => {});
    it('should require uppercase', async () => {});
    it('should require numbers', async () => {});
  });

  describe('MFA', () => {
    it('should enable MFA', async () => {});
    it('should set MFA configuration', async () => {});
  });
  // ... 10+ more tests
});
```

**✅ Good - Flat structure with grouped assertions:**

```typescript
describe('UserPool', () => {
  it('should configure user pool with security settings', async () => {
    // Groups password policy, MFA, and email verification
    template.resourceCountIs('AWS::Cognito::UserPool', 1);
    template.hasResourceProperties(
      'AWS::Cognito::UserPool',
      Match.objectLike({
        PasswordPolicy: Match.objectLike({
          MinimumLength: 8,
          RequireLowercase: true,
          RequireUppercase: true,
          RequireNumbers: true,
        }),
        MfaConfiguration: 'OPTIONAL',
        AutoVerifiedAttributes: ['email'],
      })
    );
  });

  it('should create user pool client with OAuth settings', async () => {
    // Groups all client configuration
    template.hasResourceProperties(
      'AWS::Cognito::UserPoolClient',
      Match.objectLike({
        UserPoolId: Match.anyValue(),
        AllowedOAuthFlows: ['code'],
        AllowedOAuthScopes: ['openid', 'email', 'profile'],
      })
    );
  });

  it('should reference user pool ARN in Lambda environment', async () => {
    // Tests cross-resource references
    template.hasResourceProperties(
      'AWS::Lambda::Function',
      Match.objectLike({
        Environment: Match.objectLike({
          Variables: Match.objectLike({
            USER_POOL_ARN: Match.anyValue(),
          }),
        }),
      })
    );
  });
});
```

**Key benefits**:

- 3 grouped tests instead of 10+ micro-tests
- Easier to maintain and update
- Clearer test intentions
- Faster execution

### Test Descriptions

```typescript
// ✅ GOOD - Describes behavior
it('should enforce encryption at rest', async () => {});
it('should block public access by default', async () => {});
it('should reference user pool in client', async () => {});

// ❌ BAD - Too vague
it('should work', async () => {});
it('should create bucket', async () => {});
it('test encryption', async () => {});
```

## Best Practices Summary

### Testing Strategy

1. **Prefer API tests over domain tests** - Test from user's perspective
2. **Use fine-grained assertions for regressions** - Snapshot tests are for refactoring
3. **Test critical infrastructure properties** - Security, references, policies
4. **Don't test implementation details** - Tests should survive refactoring

### Writing Tests

5. **Group related assertions together** - Test 5-6 properties of same resource in one test
6. **Aim for 3-6 tests per construct** - Avoid over-fragmentation with 10+ micro-tests
7. **Use descriptive test names** - Describe the resource/feature being validated
8. **Isolate tests** - Create separate scopes per test to avoid conflicts
9. **Refactor common test code** - Extract fixtures and helpers

### Technical Requirements

10. **Always use `Match.objectLike()`** - Flexible, won't break on CDK updates
11. **Run sequentially** - Set `fileParallelism: false` for SST
12. **Initialize SST appropriately** - Use `beforeAll()` for shared config, per-test for different params
13. **Mock account-specific helpers** - Avoid environment dependencies

### Code Organization

14. **Co-locate tests** - Keep tests next to constructs
15. **Use AWS IAC MCP tools** - Understand CloudFormation resource schemas
16. **Invest in test quality** - Tests live as long as your code

## Additional Resources

- [AWS CDK Testing Guide](https://docs.aws.amazon.com/cdk/v2/guide/testing.html)
- [SST v2 Documentation](https://v2.sst.dev/)
- [SST v2 Constructs](https://v2.sst.dev/constructs)
- [SST v2 Testing](https://v2.sst.dev/testing)
- [CloudFormation Resource Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)
- [Vitest Documentation](https://vitest.dev)
